#!/bin/bash
########
##start search in categories
#calculate package path
#CP category/package
#echo "arguments $@"

search_in_categories() {
# if / in an argument, then category "known" (required to check if category really available)
# in this case we use search directly with this category
# if no / , then search package via each category
# if = is used, then we prefer this version at the end of search (if stability allow it)
#
# media-libs/libpng
# =media-libs/libpng-1.6.32
# =libpng-1.6.32
# some-category/p1_oauth2-0.63
# category/go-sys
# some-category/go-sys-20160729
# differen-category/localshell-0.1_rev2sec3
# rev2 - revision of buildme
# sev3 - security update

cd "$SIMPLEBUILD_DIR"
source "$SIMPLEBUILD_DIR"/bashrc
source /usr/lib/simple/libsimple


for arg in "$@"; do

debug_message "argument to search is: $arg"

get_variables "$arg"
get_expression

#ebany poisk
if [ -v category ]; then
	debug_message "category known"
	while read -r line; do
		if [ "$line" = "$category" ]; then
			CATEGORY="$line"
		fi
	done <"$BUILDME_DIR"/profiles/categories
	unset line

	if [[ "$CATEGORY" = "$category" ]]; then
		if [ "$REMOVE" = "true" ]; then
			[ ! -d "/var/lib/pkg/$category" ] && echo "/var/lib/pkg/$category not a directory" && return 1
			shopt -s nullglob extglob
			pushd "/var/lib/pkg/$category" > /dev/null 2>&1 || return 1
			for d in *; do
				if [[ -d "$d" && "$d" = "$package"* ]]; then
					# with whitespace!!!
					filenames+="$category/$d "
				fi
				unset d
			done
			shopt -u nullglob extglob
			popd > /dev/null 2>&1 || return 1
		else
			[ ! -d "$BUILDME_DIR/$category/$package" ] && echo "$BUILDME_DIR/$category/$package not a directory" && return 1
			shopt -s nullglob extglob
			pushd "$BUILDME_DIR/$category/$package" > /dev/null 2>&1 || return 1
			for f in *; do
				if [[ -f "$f" && "$f" = *'.buildme' ]]; then
					# with whitespace!!!
					filenames+="$f "
				fi
				unset f
			done
			shopt -u nullglob extglob
			popd > /dev/null 2>&1 || return 1
		fi

		if [ -z "$filenames" ]; then
			if [ "$REMOVE" = 'true' ]; then
				echo "Category is definded but no matched directory in /var/lib/pkg/$category is not found"
			else
				echo "Category is definded but no any file in $BUILDME_DIR/$category/$package is not found"
			fi
			return 1
		fi

		debug_message "list after search:"
		debug_message "$filenames"
	else
		echo "Category $category does not exist"
		return 1
	fi

else
	debug_message "category not known"
	count=0
	if [ "$REMOVE" = 'true' ]; then
		shopt -s nullglob extglob globstar
		pushd "/var/lib/pkg" > /dev/null 2>&1 || return 1
		while read -r entry; do
			for d in **; do
				if [[ -d "$d" && "$d" = "$entry"/"$package"* ]]; then
					CPV+="$d " && count=$((count + 1))
				fi
			done
		done <"$BUILDME_DIR"/profiles/categories
		popd > /dev/null 2>&1 || return 1
		shopt -u nullglob extglob globstar

		found=$(echo -e $CPV) #eat whitespace

		if [ -z "$found" ]; then
			if [ "$REMOVE" = 'true' ]; then
				echo "Category for $raw_package in /var/lib/pkg is not found. Package not installed?"
			else
				echo "Category for $raw_package is not found"
			fi
			return 1
		fi

		filenames="$found"

	else

		pushd "$BUILDME_DIR" > /dev/null 2>&1 || return 1
		while read -r entry; do
			if [ -d "$entry"/"$package" ]; then
				found+="$entry/$package " && count=$((count + 1))
			fi
		done <"$BUILDME_DIR"/profiles/categories
		popd > /dev/null 2>&1 || return 1

		found=$(echo -e $found) #eat whitespace

		if [ "$count" -gt "1" ]; then
			echo -n 'Sorry, we found many packages. Try to use '
			echo "$found"
			return 1
		fi

		if [ -z "$found" ]; then
			echo "Category for $raw_package is not found"
			return 1
		fi

		get_variables "$found"

		debug_message "category: $category"
		debug_message "package: $package"

		pushd "$BUILDME_DIR/$category/$package" > /dev/null 2>&1 || return 1
		shopt -s nullglob extglob
		for f in *; do
			if [[ -f "$f" && "$f" = *'.buildme' ]]; then
				# with whitespace!!!
				filenames+="$f "
			fi
			unset f
		done
		shopt -u nullglob extglob
		popd > /dev/null 2>&1 || return 1

		if [ -z "$filenames" ]; then
			echo "Category is definded but no one file in directory $BUILDME_DIR/$CP is not found"
			return 1
		fi

	fi

	debug_message "list after search:"
	debug_message "$filenames"
fi

#if required only specific version
if [ ! -z "$ver_modif" ]; then
	for F in $filenames; do
		debug_message "F: $F"
		if [ "$REMOVE" = "true" ]; then
			# only regexp is different. rewrite it to be shortly
			if [[ "$F" =~ $regex3 ]]; then
				debug_message "version from filenames: ${BASH_REMATCH[3]}"
				debug_message "expr: $EXPR"

				if [ "${BASH_REMATCH[3]}" "$EXPR" "$version" ]; then
					sortedbyversion+="$F "
				fi
			fi
		else
			if [[ "$F" =~ $regex4 ]]; then
				debug_message "version from filenames: ${BASH_REMATCH[3]}"
				debug_message "expr: $EXPR"

				if [ "${BASH_REMATCH[3]}" "$EXPR" "$version" ]; then
					sortedbyversion+="$F "
				fi
			fi
		fi
	done
	unset EXPR
else
	sortedbyversion="$filenames"
fi

[[ -z "$sortedbyversion" ]] && echo "no version found" && return 1
debug_message "sorted by version: $sortedbyversion"

#checking stability
# don't care about stability if REMOVE
if [ "$REMOVE" = "true" ]; then
	REMOVE_LIST+="$sortedbyversion "
else
	for F in $sortedbyversion; do
		debug_message "F: $F"
		var_stability=$(grep STABILITY "$BUILDME_DIR/$category/$package/$F" | sed -nr 's/STABILITY="([~_a-zA-Z0-9${} ]*)".*/\1/p')
		make_stability=$STABILITY

		debug_message "var stability: $var_stability"
		debug_message "make stability: $make_stability"

		for S in $var_stability; do
			if [ "$S" = "$make_stability" ]; then
				sortedbystability+="$F "
			fi
		done
	done

	debug_message "sortedbystability: $sortedbystability"

	#checking for more new package
	# will delete all versions if REMOVE and no version definded

	for I in $sortedbystability; do
		debug_message "I: $I"
		max=0

		if [[ "$I" =~ $regex4 ]]; then
			if [[ "${BASH_REMATCH[3]}" > "$max" ]]; then
				max="${BASH_REMATCH[3]}"
			fi
		fi
		debug_message "max: $max"
	done

	if [ "$max" = 0 ]; then
		echo "no mached version found"
		return 1
	fi

	CATEGORY=$category
	PACKAGE=$package
	VERSION=$max

######################################################
	# checking if package is installed
	if [ -d /var/lib/pkg/"$CATEGORY"/"$PACKAGE"-"$VERSION" ]; then
		# if package and version the same then the package is installed
		debug_message "package with the same version already installed"

		#check if package already in list
		alreadylisted=no
		for p in $INSTALLED_LIST; do
			if [ "$CATEGORY/$PACKAGE-$VERSION" = $p ]; then
				alreadylisted=yes
			fi
		done
        	if [ $alreadylisted = no ]; then
			INSTALLED_LIST+="$CATEGORY/$PACKAGE-$VERSION "
		fi
		unset alreadylisted
	else
		#checking if some version of this package is installed
		shopt -s nullglob
		for d in /var/lib/pkg/"$CATEGORY"/"$PACKAGE"-* ; do
			debug_message "installed $d package with another version"
		done
		shopt -u nullglob

		if [ -v d ]; then
			echo "installed $d package with another version"
			echo "update case"
			echo "not implemented yet"
			return 1
		fi
	fi
#######################################################

	if [ "$look_for_dep" = "yes" ]; then
		DEP="$CATEGORY/$PACKAGE-$VERSION"
		#add_variable DEP
	else
		if [ -z $USERLIST_TO_INSTALL ]; then
			USERLIST_TO_INSTALL="$CATEGORY/$PACKAGE-$VERSION"
		else
			NEWLIST=(${USERLIST_TO_INSTALL[@]} "$CATEGORY/$PACKAGE-$VERSION")
			USERLIST_TO_INSTALL=(${NEWLIST[@]})
		fi
		#echo ===================================
		#echo "list to install from search: ${USERLIST_TO_INSTALL[@]}"
	fi

# end of REMOVE
fi

unset CATEGORY PACKAGE VERSION
unset same_version less_version more_version
unset CP category package raw_package separator ver_modif ver_sep version
unset count found max d F I S filenames var_stability make_stability sortedbystability sortedbyversion

#show all variables
# ( set -o posix ; set )

done

}

################################################################################

get_dep(){
unset look
if [[ $look_for_dep = yes ]]; then
	look=$DEP
else
	look=${USERLIST_TO_INSTALL[@]}
fi

for CPV in $look; do
	debug_message "CPV $CPV"
	get_variables $CPV

	if [[ $(cat "$BUILDME_DIR/$CATEGORY/$PACKAGE/$PACKAGE-$VERSION.buildme") =~ $regexBDEP ]]; then
		bdep_line=$(echo "${BASH_REMATCH[2]}" | tr -s [:space:] ' ')
		debug_message "bdep_line ${bdep_line[@]}"
		if [[ "$bdep_line" = ' ' ]]; then
			debug_message "bdep_line is definded but empty"
		else
			count=0
			for b in ${bdep_line[@]}; do
				if [[ $b =~ $check_use ]]; then
					debug_message "USE: ${BASH_REMATCH[1]}"

					count=$((count + 1))
					if [[ $(is_use_needed "${BASH_REMATCH[1]}") = true ]]; then
						debug_message "use needed"
						needed=true
					else
						debug_message "use NOT needed"
						needed=false
					fi
				else
					if [[ $count -gt 0 ]]; then
						if [[ $b != "(" && $b != ")" && $needed = true ]]; then
							bdep="$bdep $b"
						fi
					fi
				fi
				if [[ $b = ")" ]]; then
					count=$((count - 1))
				fi
				if [[ $count = 0 ]]; then
					if [[ $b != "(" && $b != ")" ]]; then
						bdep="$bdep $b"
					fi
				fi
			done
		fi
	else
		debug_message "BDEPEND is not definded"

	fi

BDEP=("$bdep")
unset needed count b bdep bdep_line category package raw_package ver_modif ver_sep version

#################################################

	for dep in ${BDEP[@]}; do
		look_for_dep=yes
		search_in_categories "$dep"

		count=0
		for pack in ${USERLIST_TO_INSTALL[@]}; do
			if [[ "$pack" != "$DEP" ]]; then
				count=$((count + 1))
			fi
		done

		if [[ "$count" = "${#USERLIST_TO_INSTALL[*]}" ]]; then
			debug_message "new dependency $DEP"

			USERLIST_TO_INSTALL=("$DEP" "${USERLIST_TO_INSTALL[@]}")
			debug_message "list after adding ${USERLIST_TO_INSTALL[@]}"

			get_dep

		else
			debug_message "$DEP should be before $CPV"

			USERLIST_TO_INSTALL=($(echo ${USERLIST_TO_INSTALL[@]} | sed -r "s,$DEP,,g"))
			USERLIST_TO_INSTALL=($DEP ${USERLIST_TO_INSTALL[@]})
			debug_message "list after moving ${USERLIST_TO_INSTALL[@]}"

			get_dep
		fi

	done

	look_for_dep=no
	unset DEP CATEGORY PACKAGE VERSION BDEP pack count category package raw_package ver_modif ver_sep version

done

}
################################################################################

search_in_categories $@ || exit 1

if [ "$REMOVE" = "true" ]; then
	add_variable REMOVE_LIST
	print_variable >> "$SIMPLEBUILD_DIR/bashrc"
	exit 0
fi

get_dep || exit 1

if [ -v INSTALLED_LIST ]; then
	add_variable INSTALLED_LIST
fi

add_variable USERLIST_TO_INSTALL
print_variable >> "$SIMPLEBUILD_DIR/bashrc"

